<!DOCTYPE html>
<html lang="en" style="font-size: 10px; font-family: Roboto, Arial, sans-serif">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <meta content="utf-8" http-equiv="encoding" />
    <title>Social Stream - YouTube</title>
    <link rel="icon" href="https://www.youtube.com/favicon.ico" type="image/x-icon">
    <style>
        .hidden { display: none!important; }
        body {
            background-color: #ddd;
            font-size: 14px;
            margin: 0;
            padding: 20px;
        }
        .auth-button, .sign-out-button, .connect-button {
            background-color: #FF0000;
            color: white;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        .auth-button:hover, .connect-button:hover {
            background-color: #D30000;
        }
        .sign-out-button {
            background-color: #f44336;
        }
        .sign-out-button:hover {
            background-color: #d32f2f;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .chat-badge {
            margin-right: 2px;
            vertical-align: middle;
            height: 18px;
            width: auto;
        }
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .text-center { text-align: center; }
        
        /* Header styles */
        .channel-header {
            background: white;
            padding: 12px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .header-info {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-grow: 1;
        }
        .header-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .header-item span:first-child {
            font-weight: bold;
            color: #FF0000;
        }
        
        /* Channel input */
        .channel-input-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .channel-input {
            padding: 8px;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 150px;
        }
        
        /* Stats grid */
        .stats-container {
            background: white;
            padding: 12px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .stats-container h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        .stat-box {
            background: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
        }
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #FF0000;
        }
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 2px;
        }
        
        /* Chat container */
        .chat-container {
            background: white;
            border-radius: 4px;
            padding: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            flex-grow: 1;
            display: flex;
            flex-direction: column;
			
        }
        .chat-container h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        #textarea {
            flex-grow: 1;
            min-height: 400px;
            overflow-y: auto;
            margin-bottom: 10px;
        }
        .chat-input {
            display: flex;
            gap: 8px;
        }
        .chat-input input {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        /* Sidebar components */
        .permissions-container,
        .recent-events {
            background: white;
            padding: 12px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        #permissions-info:empty {
            display: none!important;
        }
        .permissions-header {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 8px;
            color: #FF0000;
        }
        .permission-item {
            padding: 4px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
        }
        .recent-events h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
        }
        .event-item {
            padding: 6px 0;
            border-bottom: 1px solid #eee;
            font-size: 13px;
        }
        #textarea div {
            padding-bottom: 4px;
        }
		.chat-container {
			background: white;
			border-radius: 4px;
			padding: 12px;
			box-shadow: 0 1px 3px rgba(0,0,0,0.1);
			flex-grow: 1;
			display: flex;
			flex-direction: column;
		}
		.chat-container h3 {
			margin: 0 0 10px 0;
			font-size: 16px;
		}
		#textarea {
			flex-grow: 1;
			height: 300px;
			max-height: 300px;
			overflow-y: auto;
			margin-bottom: 10px;
		}
		.header-avatar {
			width: 32px;
			height: 32px;
			border-radius: 50%;
			margin-right: 8px;
		}
		.user-info {
			display: flex;
			align-items: center;
		}
		.user-info-text {
			margin-right: 12px;
		}
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <div class="auth text-center">
				<a id="auth-link" class="auth-button">Sign in to YouTube</a>
				<div style="margin-top: 15px; font-size: 13px; max-width: 600px; margin-left: auto; margin-right: auto; line-height: 1.5;">
					<p>This tool requires OAuth sign-in to access YouTube's data APIs.</p>
					<p>Please note: Events related to subscriptions, memberships, and followers are only available for your own channel. Chat functionality will still work across most public channels.</p>
				</div>
			</div>
            
            <div class="hidden socket">
                <div class="channel-header">
					<div class="header-info">
						<div class="user-info">
							<div id="user-avatar"></div>
							<div class="user-info-text">
								<div class="header-item">
									<span>User:</span>
									<span id="current-user">Not signed in</span>
								</div>
							</div>
						</div>
						<div class="header-item">
							<span>Target:</span> <span id="current-channel">No target</span>
						</div>
						<div class="channel-input-container">
							<input type="text" id="channel-input" class="channel-input" placeholder="Enter channel name">
							<input type="text" id="video-input" class="channel-input" placeholder="Enter video ID">
							<button id="connect-button" class="connect-button">Connect</button>
						</div>
					</div>
					<button id="sign-out-button" class="sign-out-button">Sign Out</button>
				</div>

                <div class="stats-container">
                    <h3>Channel Statistics</h3>
                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="stat-value" id="subscriber-count">-</div>
                            <div class="stat-label">Subscribers</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="viewer-count">-</div>
                            <div class="stat-label">Live Viewers</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-value" id="likes-count">-</div>
                            <div class="stat-label">Likes</div>
                        </div>
                    </div>
                </div>

                <div class="chat-container">
                    <h3>Chat Messages</h3>
                    <div id="textarea" class="ws-output"></div>
                    <div class="chat-input">
                        <input type="text" id="input-text" placeholder="Send Message">
                        <button id="sendmessage" class="auth-button">Send</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="sidebar hidden socket">
            <div class="permissions-container" id="permissions-info"></div>
            <div class="recent-events">
                <h4>Recent Events</h4>
                <div id="events-list"></div>
            </div>
        </div>
    </div>
<script>


try {
    var clientId = '689627108309-isbjas8fmbc7sucmbm7gkqjapk7btbsi.apps.googleusercontent.com';
    var redirectURI = window.location.href.split("/youtube")[0]+"/youtube.html";
    var scope = 'https://www.googleapis.com/auth/youtube.readonly https://www.googleapis.com/auth/youtube https://www.googleapis.com/auth/youtube.force-ssl';
    var username = "";
    var channel = '';
    var videoId = '';
    let pollInterval;
    var lastMessageTime = null;
    var liveChatId = null;
    var nextPageToken = null;
    var isPolling = false;
    var userDetails = {};
    var currentStream = null;
	var messageQueue = [];
	var displayInterval;
	var isDisplaying = false;
	var quickPollCount = 0
    var urlParams = new URLSearchParams(window.location.search);
    var hashParams = new URLSearchParams(window.location.hash.slice(1));
	function getStoredToken() {
		const storedToken = localStorage.getItem('youtubeOAuthToken');
		const tokenExpiry = localStorage.getItem('youtubeOAuthExpiry');
		const refreshToken = localStorage.getItem('youtubeRefreshToken');
		if (storedToken && tokenExpiry && new Date().getTime() < parseInt(tokenExpiry)) {
			return storedToken;
		} else if (refreshToken) {
			refreshAccessToken(refreshToken);
			return null;
		} else {
			clearStoredToken();
			return null;
		}
	}
	function setStoredToken(token, expiresIn = 3600, refresh = null) {
		const expiryTime = new Date().getTime() + (expiresIn * 1000);
		localStorage.setItem('youtubeOAuthToken', token);
		localStorage.setItem('youtubeOAuthExpiry', expiryTime.toString());
		if (refresh) {
			localStorage.setItem('youtubeRefreshToken', refresh);
		}
	}
	function clearStoredToken() {
		localStorage.removeItem('youtubeOAuthToken');
		localStorage.removeItem('youtubeOAuthExpiry');
		localStorage.removeItem('youtubeRefreshToken');
		localStorage.removeItem('youtubeChannel');
        localStorage.removeItem('youtubeVideoId');
	}
    function showAuthButton() {
        const authElement = document.querySelector('.auth');
        if (authElement) authElement.classList.remove("hidden");
        document.querySelectorAll('.socket').forEach(ele=>ele.classList.add('hidden'));
    }
    function showSocketInterface() {
        const authElement = document.querySelector('.auth');
        document.querySelectorAll('.socket').forEach(ele=>ele.classList.remove('hidden'));
        if (authElement) authElement.classList.add("hidden");
    }
	function initializePage() {
		urlParams = new URLSearchParams(window.location.search);
		hashParams = new URLSearchParams(window.location.hash.slice(1));
		const urlVideoIdParam = urlParams.get("videoId") || urlParams.get("video_id") || hashParams.get("videoId");
		const urlChannelParam = urlParams.get("channel") || urlParams.get("username") || hashParams.get("channel");
		
		// Store URL parameters in sessionStorage for post-auth redirect
		if (urlVideoIdParam || urlChannelParam) {
			sessionStorage.setItem("youtubeRedirectVideoId", urlVideoIdParam || "");
			sessionStorage.setItem("youtubeRedirectChannel", urlChannelParam || "");
		}
		
		if (urlVideoIdParam) {
			videoId = urlVideoIdParam;
			channel = '';
			localStorage.setItem("youtubeVideoId", videoId);
			localStorage.removeItem("youtubeChannel");
		} else if (urlChannelParam) {
			channel = urlChannelParam;
			videoId = '';
			localStorage.setItem("youtubeChannel", channel);
			localStorage.removeItem("youtubeVideoId");
		} else {
			videoId = localStorage.getItem("youtubeVideoId") || "";
			if (videoId) {
				channel = '';
				localStorage.removeItem("youtubeChannel");
			} else {
				channel = localStorage.getItem("youtubeChannel") || "";
			}
		}
		
		const signOutButton = document.getElementById('sign-out-button');
		if (signOutButton) signOutButton.addEventListener('click', signOut);
		
		const authLink = document.getElementById('auth-link');
		if (authLink) {
			authLink.addEventListener('click', function(e) {
				e.preventDefault();
				window.location.href = authUrl();
			});
		}
		
		const sendButton = document.querySelector('#sendmessage');
		if (sendButton) sendButton.onclick = handleSendMessage;
		
		const inputText = document.querySelector('#input-text');
		if (inputText) inputText.addEventListener('keypress', handleEnterKey);
		
		const connectButton = document.getElementById('connect-button');
		if (connectButton) connectButton.addEventListener('click', handleConnect);
		
		const channelInput = document.getElementById('channel-input');
		const videoInput = document.getElementById('video-input');
		
		if (channelInput) {
			channelInput.addEventListener('keypress', function(event) {
				if (event.key === 'Enter') handleConnect();
			});
		}
		
		if (videoInput) {
			videoInput.addEventListener('keypress', function(event) {
				if (event.key === 'Enter') handleConnect();
			});
		}
		
		// If URL parameters are present, hide the inputs
		if (urlVideoIdParam || urlChannelParam) {
			const channelInputContainer = document.querySelector('.channel-input-container');
			if (channelInputContainer) channelInputContainer.classList.add('hidden');
		}
		
		if (urlParams.has('code')) {
			handleAuthCallback();
			return;
		}
		
		const storedToken = getStoredToken();
		if (storedToken) {
			verifyAndUseToken(storedToken);
		} else if (window.location.hash && window.location.hash.includes('access_token')) {
			parseFragment(window.location.hash);
		} else {
			showAuthButton();
		}
	}
	function verifyAndUseToken(token) {
		try {
			getUserInfo(token).then(userInfo => {
				if (userInfo && userInfo.items && userInfo.items.length > 0) {
					const userItem = userInfo.items[0];
					username = userItem.snippet.title;
					
					// Add user avatar to the header
					if (userItem.snippet.thumbnails && userItem.snippet.thumbnails.default) {
						const avatarContainer = document.getElementById('user-avatar');
						if (avatarContainer) {
							avatarContainer.innerHTML = '';
							const userImage = document.createElement('img');
							userImage.src = userItem.snippet.thumbnails.default.url;
							userImage.className = 'header-avatar';
							avatarContainer.appendChild(userImage);
						}
					}
					
					// Check for post-auth redirect parameters
					const redirectVideoId = sessionStorage.getItem("youtubeRedirectVideoId");
					const redirectChannel = sessionStorage.getItem("youtubeRedirectChannel");
					
					if (redirectVideoId) {
						videoId = redirectVideoId;
						channel = '';
						connect(videoId);
						sessionStorage.removeItem("youtubeRedirectVideoId");
						sessionStorage.removeItem("youtubeRedirectChannel");
					} else if (redirectChannel) {
						channel = redirectChannel;
						videoId = '';
						document.getElementById('channel-input').value = channel;
						connect();
						sessionStorage.removeItem("youtubeRedirectVideoId");
						sessionStorage.removeItem("youtubeRedirectChannel");
					} else if (videoId) {
						connect(videoId);
					} else if (channel) {
						document.getElementById('channel-input').value = channel;
						connect();
					} else {
						updateHeaderInfo(username, 'No target specified');
						const channelInputContainer = document.querySelector('.channel-input-container');
						if (channelInputContainer) channelInputContainer.classList.remove('hidden');
						
						// Show welcome message instead of error when no target is specified
						document.getElementById('textarea').innerHTML = '<div>Welcome! Please enter a YouTube channel name or video ID to connect.</div>';
						
						// Clear any previous error stats
						document.getElementById('viewer-count').textContent = '-';
						document.getElementById('subscriber-count').textContent = '-';
						document.getElementById('likes-count').textContent = '-';
					}
					showSocketInterface();
				} else {
					refreshToken();
				}
			}).catch(error => {
				if (error.message && error.message.includes('401')) {
					refreshAccessToken(localStorage.getItem('youtubeRefreshToken'));
				} else {
					console.error('Error validating token:', error);
					clearStoredToken();
					showAuthButton();
				}
			});
		} catch (error) {
			console.error('Error in verifyAndUseToken:', error);
			clearStoredToken();
			showAuthButton();
		}
	}
	function parseFragment(hash) {
		const tokens = {};
		hash.replace('#', '').split('&').forEach(param => {
			const [key, value] = param.split('=');
			tokens[key] = value;
		});
		if (tokens.access_token) {
			const expiresIn = tokens.expires_in ? parseInt(tokens.expires_in) : 3600;
			setStoredToken(tokens.access_token, expiresIn);
            window.history.replaceState({}, document.title, redirectURI);
			verifyAndUseToken(tokens.access_token);
		} else {
			console.error('No access token found in URL fragment');
			showAuthButton();
		}
	}
	async function refreshToken() {
		console.log('Attempting to refresh token or re-authenticate.');
        const storedRefreshToken = localStorage.getItem('youtubeRefreshToken');
        if (storedRefreshToken) {
            const refreshed = await refreshAccessToken(storedRefreshToken);
            if (refreshed) return;
        }
		clearStoredToken();
		showAuthButton();
	}
	function authUrl() {
		const state = nonce(15);
		sessionStorage.youtubeOAuthState = state;
		return 'https://ytauth.socialstream.ninja/auth' +
			'?client_id=' + clientId +
			'&redirect_uri=' + encodeURIComponent(redirectURI) +
			'&state=' + state;
	}
	async function refreshAccessToken(refreshTokenValue) {
		if (!refreshTokenValue) {
            console.log('No refresh token available for refreshAccessToken.');
            clearStoredToken();
            showAuthButton();
            return false;
        }
		try {
			const response = await fetch('https://ytauth.socialstream.ninja/refresh', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ refresh_token: refreshTokenValue })
			});
			if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
			const data = await response.json();
			setStoredToken(data.access_token, data.expires_in, data.refresh_token || refreshTokenValue);
			setTimeout(() => { verifyAndUseToken(data.access_token); }, 500);
			return true;
		} catch (error) {
			console.error('Error refreshing token:', error);
			clearStoredToken();
			showAuthButton();
			return false;
		}
	}
	async function handleAuthCallback() {
		const urlParams = new URLSearchParams(window.location.search);
		const code = urlParams.get('code');
		const state = urlParams.get('state');
		if (state !== sessionStorage.youtubeOAuthState) {
			console.error('State mismatch - possible CSRF attack');
			showAuthButton(); return;
		}
		if (code) {
			try {
				const response = await fetch('https://ytauth.socialstream.ninja/token', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ code: code, redirect_uri: redirectURI })
				});
				if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
				const data = await response.json();
				setStoredToken(data.access_token, data.expires_in, data.refresh_token);
				window.history.replaceState({}, document.title, redirectURI);
				verifyAndUseToken(data.access_token);
			} catch (error) {
				console.error('Error exchanging code for tokens:', error);
				showAuthButton();
			}
		}
	}
    function nonce(length) {
        var text = "";
        var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        for (var i = 0; i < length; i++) {
            text += possible.charAt(Math.floor(Math.random() * possible.length));
        }
        return text;
    }
    function signOut() {
        clearPolling();
        clearStoredToken();
        username = "";
        channel = '';
        videoId = '';
        updateHeaderInfo(null, null);
        document.querySelectorAll('.socket').forEach(ele=>ele.classList.add('hidden'));
        document.querySelector('.auth').classList.remove('hidden');
        document.querySelector('#textarea').innerHTML = '';
        document.getElementById('viewer-count').textContent = '-';
        document.getElementById('subscriber-count').textContent = '-';
        document.getElementById('likes-count').textContent = '-';
        document.getElementById('events-list').innerHTML = '';
        document.getElementById('permissions-info').innerHTML = '';
        const channelInputContainer = document.querySelector('.channel-input-container');
        if (channelInputContainer) channelInputContainer.classList.remove('hidden');
        document.getElementById('channel-input').value = '';
        console.log('Signed out successfully');
    }
    function handleEnterKey(event) {
        if (event.key === 'Enter') handleSendMessage(event);
    }
    function handleSendMessage(event) {
        event.preventDefault();
        const inputElement = document.querySelector('#input-text');
        if (inputElement) {
            var msg = inputElement.value.trim();
            if (msg && liveChatId) {
                sendChatMessage(msg).then(response => {
                    if (response && response.success) {
                        inputElement.value = "";
                        processMessage({
                            authorName: username,
                            message: msg,
                            profileImageUrl: response.authorDetails?.profileImageUrl || '',
                            isChatOwner: response.authorDetails?.isChatOwner || false,
                            isChatSponsor: response.authorDetails?.isChatSponsor || false,
                            isChatModerator: response.authorDetails?.isChatModerator || false
                        });
                    }
                });
            }
        }
    }
    function handleConnect() {
		const channelInput = document.getElementById('channel-input');
		const videoInput = document.getElementById('video-input');
		const channelNameFromInput = channelInput.value.trim();
		const videoIdFromInput = videoInput.value.trim();
		
		if (videoIdFromInput) {
			localStorage.setItem('youtubeVideoId', videoIdFromInput);
			localStorage.removeItem('youtubeChannel');
			videoId = videoIdFromInput;
			channel = '';
			updateHeaderInfo(username, "Loading video: " + videoId);
			connect(videoId);
			videoInput.value = '';
		} else if (channelNameFromInput) {
			localStorage.setItem('youtubeChannel', channelNameFromInput);
			localStorage.removeItem('youtubeVideoId');
			channel = channelNameFromInput;
			videoId = '';
			updateHeaderInfo(username, "Channel: " + channel);
			connect();
			channelInput.value = '';
		}
	}
    async function getUserInfo(token) {
        try {
            const response = await fetchWithTimeout('https://www.googleapis.com/youtube/v3/channels?part=snippet&mine=true', 5000,
                { 'Authorization': `Bearer ${token}` }
            );
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            return await response.json();
        } catch (error) {
            console.error('Error fetching user info:', error);
            if (error.message && error.message.includes('401')) throw error;
            return null;
        }
    }
    async function getChannelInfo(channelIdentifier) {
        const token = getStoredToken();
        if (!token) return null;
        if (userDetails[channelIdentifier]) return userDetails[channelIdentifier];
        try {
            let response = await fetchWithTimeout(
                `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&id=${channelIdentifier}`, 5000,
                { 'Authorization': `Bearer ${token}` }
            );
            let data = await response.json();
            if ((!data.items || data.items.length === 0) && !channelIdentifier.startsWith('UC')) {
                response = await fetchWithTimeout(
                    `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&forUsername=${channelIdentifier}`, 5000,
                    { 'Authorization': `Bearer ${token}` }
                );
                data = await response.json();
            }
            if ((!data.items || data.items.length === 0) && !channelIdentifier.startsWith('UC')) {
                response = await fetchWithTimeout(
                    `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${channelIdentifier}&type=channel&maxResults=1`, 5000,
                    { 'Authorization': `Bearer ${token}` }
                );
                const searchData = await response.json();
                if (searchData.items && searchData.items.length > 0) {
                    const channelIdFromResult = searchData.items[0].id.channelId;
                    response = await fetchWithTimeout(
                        `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&id=${channelIdFromResult}`, 5000,
                        { 'Authorization': `Bearer ${token}` }
                    );
                    data = await response.json();
                }
            }
            if (data.items && data.items.length > 0) {
                userDetails[channelIdentifier] = data.items[0];
                userDetails[data.items[0].id] = data.items[0];
                return data.items[0];
            }
            return null;
        } catch (error) {
            console.error('Error fetching channel info:', error);
            return null;
        }
    }
    async function getLiveStreamInfo(channelId) {
        const token = getStoredToken();
        if (!token) return null;
        try {
            const response = await fetchWithTimeout(
                `https://www.googleapis.com/youtube/v3/search?part=snippet&channelId=${channelId}&eventType=live&type=video&maxResults=1`, 5000,
                { 'Authorization': `Bearer ${token}` }
            );
            const data = await response.json();
            if (data.items && data.items.length > 0) {
                const videoIdFromResult = data.items[0].id.videoId;
                const detailsResponse = await fetchWithTimeout(
                    `https://www.googleapis.com/youtube/v3/videos?part=snippet,liveStreamingDetails,statistics&id=${videoIdFromResult}`, 5000,
                    { 'Authorization': `Bearer ${token}` }
                );
                const detailsData = await detailsResponse.json();
                if (detailsData.items && detailsData.items.length > 0) {
                    return detailsData.items[0];
                }
            }
            return null;
        } catch (error) {
            console.error('Error fetching live stream info:', error);
            return null;
        }
    }
    async function getLiveChatId(videoIdForChat) {
        const token = getStoredToken();
        if (!token) return null;
        try {
            const response = await fetchWithTimeout(
                `https://www.googleapis.com/youtube/v3/videos?part=liveStreamingDetails&id=${videoIdForChat}`, 5000,
                { 'Authorization': `Bearer ${token}` }
            );
            const data = await response.json();
            if (data.items && data.items.length > 0 && data.items[0].liveStreamingDetails) {
                return data.items[0].liveStreamingDetails.activeLiveChatId;
            }
            return null;
        } catch (error) {
            console.error('Error fetching live chat ID:', error);
            return null;
        }
    }
	function queueMessage(messageData) {
		messageQueue.push(messageData);
		if (!isDisplaying) startDisplayQueue();
	}
	function startDisplayQueue() {
		if (isDisplaying || messageQueue.length === 0) return;
		isDisplaying = true;
		displayNextMessage();
	}
	function displayNextMessage() {
		if (messageQueue.length === 0) {
			isDisplaying = false; return;
		}
		const message = messageQueue.shift();
		processMessage(message);
		let delay = 100;
		if (messageQueue.length > 50) delay = 20;
		else if (messageQueue.length > 20) delay = 50;
		else if (messageQueue.length > 5) delay = 75;
		setTimeout(displayNextMessage, delay);
	}
    async function fetchChatMessages() {
		if (!liveChatId || isPolling) return;
		isPolling = true;
		const token = getStoredToken();
        if (!token) { isPolling = false; refreshToken(); return; }
		try {
			let url = `https://www.googleapis.com/youtube/v3/liveChat/messages?liveChatId=${liveChatId}&part=snippet,authorDetails&maxResults=200`;
			if (nextPageToken) url += `&pageToken=${nextPageToken}`;
			const response = await fetchWithTimeout(url, 5000, { 'Authorization': `Bearer ${token}` });
			if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
			const data = await response.json();
			if (data.items && data.items.length > 0) {
				data.items.forEach(item => {
					const publishedAt = new Date(item.snippet.publishedAt);
					if (!lastMessageTime || publishedAt > lastMessageTime) {
						queueMessage({
							authorName: item.authorDetails.displayName,
							message: item.snippet.displayMessage,
							profileImageUrl: item.authorDetails.profileImageUrl,
							isChatOwner: item.authorDetails.isChatOwner,
							isChatSponsor: item.authorDetails.isChatSponsor,
							isChatModerator: item.authorDetails.isChatModerator,
							publishedAt
						});
						if (!lastMessageTime || publishedAt > lastMessageTime) lastMessageTime = publishedAt;
					}
				});
				const isMaxedOut = data.items.length === 200;
				if (isMaxedOut && quickPollCount < 10) {
					quickPollCount++; nextPageToken = data.nextPageToken;
					setTimeout(fetchChatMessages, 100);
				} else {
					quickPollCount = 0; nextPageToken = data.nextPageToken;
					const pollingInterval = data.pollingIntervalMillis || 5000;
					let adjustedInterval = pollingInterval;
					if (messageQueue.length > 100) adjustedInterval = Math.max(1000, pollingInterval * 0.5);
					else if (messageQueue.length > 50) adjustedInterval = Math.max(2000, pollingInterval * 0.75);
					setTimeout(fetchChatMessages, adjustedInterval);
				}
			} else {
				const pollingInterval = data.pollingIntervalMillis || 5000;
				setTimeout(fetchChatMessages, pollingInterval);
			}
			if (data.items) {
				data.items.forEach(item => {
					if (item.snippet.superChatDetails) {
						processSuperChat({
							authorName: item.authorDetails.displayName,
							amount: item.snippet.superChatDetails.amountDisplayString,
							message: item.snippet.superChatDetails.userComment,
							tier: item.snippet.superChatDetails.tier,
							profileImageUrl: item.authorDetails.profileImageUrl
						});
					}
					if (item.snippet.membershipDetails) {
						processMembership({
							authorName: item.authorDetails.displayName,
							level: item.snippet.membershipDetails.memberLevelName,
							profileImageUrl: item.authorDetails.profileImageUrl
						});
					}
				});
			}
		} catch (error) {
			console.error('Error fetching chat messages:', error);
            if (error.message && error.message.includes('401')) {
                isPolling = false;
                await refreshAccessToken(localStorage.getItem('youtubeRefreshToken'));
                return;
            }
			setTimeout(fetchChatMessages, 10000);
		} finally {
			if (response && response.ok) isPolling = false;
            else if (!error.message.includes('401')) isPolling = false;
		}
	}
    async function sendChatMessage(message) {
        const token = getStoredToken();
        if (!token || !liveChatId) return { success: false };
        try {
            const response = await fetchWithTimeout('https://www.googleapis.com/youtube/v3/liveChat/messages?part=snippet,authorDetails', 5000, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    snippet: {
                        liveChatId: liveChatId, type: 'textMessageEvent',
                        textMessageDetails: { messageText: message }
                    }
                })
            });
            if (!response.ok) {
                const errorText = await response.text(); console.error('Error sending chat message:', errorText);
                return { success: false };
            }
            const data = await response.json();
            return {
                success: true,
                authorDetails: {
                    profileImageUrl: data.authorDetails?.profileImageUrl,
                    isChatOwner: data.authorDetails?.isChatOwner,
                    isChatSponsor: data.authorDetails?.isChatSponsor,
                    isChatModerator: data.authorDetails?.isChatModerator
                }
            };
        } catch (error) {
            console.error('Error sending chat message:', error);
            return { success: false };
        }
    }
    async function getStreamStats() {
        if (!currentStream || !currentStream.id) return;
        const token = getStoredToken();
        if (!token) return;
        try {
            const response = await fetchWithTimeout(
                `https://www.googleapis.com/youtube/v3/videos?part=statistics,liveStreamingDetails&id=${currentStream.id}`, 5000,
                { 'Authorization': `Bearer ${token}` }
            );
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            if (data.items && data.items.length > 0) {
                const stats = data.items[0];
                if (stats.liveStreamingDetails && stats.liveStreamingDetails.concurrentViewers) {
                    updateStats('viewer_update', { meta: stats.liveStreamingDetails.concurrentViewers });
                }
                if (stats.statistics && stats.statistics.likeCount) {
                    updateStats('likes_update', { meta: stats.statistics.likeCount });
                }
            }
        } catch (error) {
            console.error('Error fetching stream stats:', error);
        }
    }
    async function getSubscriberCount(channelIdForSubs) {
        const token = getStoredToken();
        if (!token) return;
        try {
            const response = await fetchWithTimeout(
                `https://www.googleapis.com/youtube/v3/channels?part=statistics&id=${channelIdForSubs}`, 5000,
                { 'Authorization': `Bearer ${token}` }
            );
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            if (data.items && data.items.length > 0 && data.items[0].statistics) {
                updateStats('subscriber_update', { meta: data.items[0].statistics.subscriberCount });
            }
        } catch (error) {
            console.error('Error fetching subscriber count:', error);
        }
    }
	function clearPolling() {
		if (pollInterval) clearInterval(pollInterval);
		pollInterval = null; liveChatId = null; nextPageToken = null;
		lastMessageTime = null; isPolling = false; currentStream = null;
		messageQueue = []; isDisplaying = false; quickPollCount = 0;
        document.getElementById('textarea').innerHTML = '';
        document.getElementById('events-list').innerHTML = '';
	}
	async function getChannelStats(channelIdForStats) {
		const token = getStoredToken();
		if (!token) return;
		try {
			const response = await fetchWithTimeout(
				`https://www.googleapis.com/youtube/v3/channels?part=statistics&id=${channelIdForStats}`, 5000,
				{ 'Authorization': `Bearer ${token}` }
			);
			if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
			const data = await response.json();
			if (data.items && data.items.length > 0 && data.items[0].statistics) {
				const stats = data.items[0].statistics;
				if (stats.subscriberCount) {
					updateStats('subscriber_update', { meta: stats.subscriberCount });
					pushMessage({ type: "youtube", event: 'subscriber_update', meta: stats.subscriberCount });
				}
				if (stats.viewCount) {
					pushMessage({ type: "youtube", event: 'view_update', meta: stats.viewCount });
				}
			}
		} catch (error) {
			console.error('Error fetching channel stats:', error);
		}
	}
    async function connect(directVideoIdParam = null) {
		clearPolling();
		const channelInputContainer = document.querySelector('.channel-input-container');
		const token = getStoredToken();
		if (!token) {
			console.error('No token available for connect');
			showAuthButton();
			return;
		}
		const videoIdToUse = directVideoIdParam || videoId;
		const channelToUse = channel;
		if (!videoIdToUse && !channelToUse) {
			updateHeaderInfo(username, 'No target specified');
			if (channelInputContainer) channelInputContainer.classList.remove('hidden');
			document.getElementById('viewer-count').textContent = '-';
			document.getElementById('subscriber-count').textContent = '-';
			document.getElementById('likes-count').textContent = '-';
			// Add a helpful message instead of an error
			document.getElementById('textarea').innerHTML = '<div>Please enter a YouTube channel name or video ID to connect.</div>';
			return;
		}
		if (channelInputContainer) channelInputContainer.classList.add('hidden');
		document.getElementById('textarea').innerHTML = '<div>Attempting to connect...</div>';
		try {
			let streamInfoToUse;
			let channelInfoForHeaderAndStats;
			let effectiveChannelIdToUse;
			let streamTitleToUse;
			let channelDisplayNameToUse;
			if (videoIdToUse) {
				const videoDetailsResponse = await fetchWithTimeout(
					`https://www.googleapis.com/youtube/v3/videos?part=snippet,liveStreamingDetails,statistics&id=${videoIdToUse}`,
					5000, { 'Authorization': `Bearer ${token}` }
				);
				if (!videoDetailsResponse.ok) throw new Error(`Failed to fetch video details for ${videoIdToUse}: ${videoDetailsResponse.status}`);
				const videoDetailsData = await videoDetailsResponse.json();
				if (!videoDetailsData.items || videoDetailsData.items.length === 0) {
					throw new Error(`Video not found or not accessible: ${videoIdToUse}`);
				}
				streamInfoToUse = videoDetailsData.items[0];
				// For non-live videos, show stats but make it clear it's not live
				const isVideoLive = streamInfoToUse.snippet.liveBroadcastContent === 'live';
				const isVideoUpcoming = streamInfoToUse.snippet.liveBroadcastContent === 'upcoming';
				const isVideoEnded = (streamInfoToUse.liveStreamingDetails && streamInfoToUse.liveStreamingDetails.actualEndTime) || 
									 streamInfoToUse.snippet.liveBroadcastContent === 'none';
				
				if (isVideoEnded) {
					liveChatId = null;
					effectiveChannelIdToUse = streamInfoToUse.snippet.channelId;
					streamTitleToUse = streamInfoToUse.snippet.title;
					channelInfoForHeaderAndStats = await getChannelInfo(effectiveChannelIdToUse);
					channelDisplayNameToUse = channelInfoForHeaderAndStats ? channelInfoForHeaderAndStats.snippet.title : streamInfoToUse.snippet.channelTitle;
					updateHeaderInfo(username, `${channelDisplayNameToUse} (Video: ${streamTitleToUse.substring(0,20)}...)`);
					document.getElementById('textarea').innerHTML = `<div>This video is not currently live. Showing stats for: ${streamTitleToUse}</div>`;
					if (streamInfoToUse.statistics) {
						document.getElementById('viewer-count').textContent = streamInfoToUse.statistics.viewCount || '-';
						document.getElementById('likes-count').textContent = streamInfoToUse.statistics.likeCount || '-';
					}
					
					// Get subscriber count for the channel
					if (channelInfoForHeaderAndStats && channelInfoForHeaderAndStats.statistics) {
						updateStats('subscriber_update', { meta: channelInfoForHeaderAndStats.statistics.subscriberCount });
					} else if (effectiveChannelIdToUse) {
						await getSubscriberCount(effectiveChannelIdToUse);
					}
					
					currentStream = { id: streamInfoToUse.id, title: streamTitleToUse, channelId: effectiveChannelIdToUse };
					return; // Return early as we can't connect to chat for a non-live video
				} else if (isVideoUpcoming) {
					liveChatId = streamInfoToUse.liveStreamingDetails?.activeLiveChatId;
					effectiveChannelIdToUse = streamInfoToUse.snippet.channelId;
					streamTitleToUse = streamInfoToUse.snippet.title;
					channelInfoForHeaderAndStats = await getChannelInfo(effectiveChannelIdToUse);
					channelDisplayNameToUse = channelInfoForHeaderAndStats ? channelInfoForHeaderAndStats.snippet.title : streamInfoToUse.snippet.channelTitle;
					updateHeaderInfo(username, `${channelDisplayNameToUse} (Upcoming: ${streamTitleToUse.substring(0,20)}...)`);
					
					if (!liveChatId) {
						document.getElementById('textarea').innerHTML = `<div>This is an upcoming stream. Chat may not be available yet.</div>`;
						document.getElementById('viewer-count').textContent = 'N/A';
						document.getElementById('likes-count').textContent = streamInfoToUse.statistics?.likeCount || '-';
					}
				} else if (!streamInfoToUse.liveStreamingDetails || !streamInfoToUse.liveStreamingDetails.activeLiveChatId) {
					throw new Error(`Video is not live or chat is not enabled: ${streamInfoToUse.snippet.title}`);
				} else {
					liveChatId = streamInfoToUse.liveStreamingDetails.activeLiveChatId;
					effectiveChannelIdToUse = streamInfoToUse.snippet.channelId;
					streamTitleToUse = streamInfoToUse.snippet.title;
					channelInfoForHeaderAndStats = await getChannelInfo(effectiveChannelIdToUse);
					channelDisplayNameToUse = channelInfoForHeaderAndStats ? channelInfoForHeaderAndStats.snippet.title : streamInfoToUse.snippet.channelTitle;
					updateHeaderInfo(username, `${channelDisplayNameToUse} (Live: ${streamTitleToUse.substring(0,20)}...)`);
				}
				currentStream = { id: streamInfoToUse.id, title: streamTitleToUse, channelId: effectiveChannelIdToUse };
			} else if (channelToUse) {
                channelInfoForHeaderAndStats = await getChannelInfo(channelToUse);
                if (!channelInfoForHeaderAndStats) {
                    throw new Error(`Channel not found: ${channelToUse}`);
                }
                channelDisplayNameToUse = channelInfoForHeaderAndStats.snippet.title;
                effectiveChannelIdToUse = channelInfoForHeaderAndStats.id;
                updateHeaderInfo(username, channelDisplayNameToUse);
                streamInfoToUse = await getLiveStreamInfo(effectiveChannelIdToUse);
                if (!streamInfoToUse) {
                    if (channelInfoForHeaderAndStats.statistics && channelInfoForHeaderAndStats.statistics.subscriberCount) {
                        updateStats('subscriber_update', { meta: channelInfoForHeaderAndStats.statistics.subscriberCount });
                    }
                    throw new Error(`No active live stream found for channel: ${channelDisplayNameToUse}`);
                }
                streamTitleToUse = streamInfoToUse.snippet.title;
                liveChatId = streamInfoToUse.liveStreamingDetails?.activeLiveChatId || await getLiveChatId(streamInfoToUse.id);
                 if (!liveChatId && streamInfoToUse.snippet.liveBroadcastContent === 'upcoming') {
                    console.log(`Stream "${streamTitleToUse}" is upcoming. Chat may not be available yet.`);
                } else if (!liveChatId) {
                    throw new Error(`No live chat available for stream: ${streamTitleToUse}`);
                }
                currentStream = { id: streamInfoToUse.id, title: streamTitleToUse, channelId: effectiveChannelIdToUse };
                updateHeaderInfo(username, channelDisplayNameToUse + (liveChatId ? ` (Live: ${streamTitleToUse.substring(0,20)}...)` : ` (Upcoming Stream)`));
            }
            document.getElementById('textarea').innerHTML = '';
            const connectMessageDiv = document.createElement("div");
            connectMessageDiv.innerText = `Target: ${channelDisplayNameToUse} - Stream: ${streamTitleToUse || 'N/A'}`;
            document.getElementById('textarea').appendChild(connectMessageDiv);
            if (streamInfoToUse) {
                if (streamInfoToUse.liveStreamingDetails && streamInfoToUse.liveStreamingDetails.concurrentViewers) {
                    updateStats('viewer_update', { meta: streamInfoToUse.liveStreamingDetails.concurrentViewers });
                } else {
                     document.getElementById('viewer-count').textContent = 'N/A';
                }
                if (streamInfoToUse.statistics && streamInfoToUse.statistics.likeCount) {
                    updateStats('likes_update', { meta: streamInfoToUse.statistics.likeCount });
                } else {
                     document.getElementById('likes-count').textContent = 'N/A';
                }
            }
            if (channelInfoForHeaderAndStats && channelInfoForHeaderAndStats.statistics && channelInfoForHeaderAndStats.statistics.subscriberCount) {
                updateStats('subscriber_update', { meta: channelInfoForHeaderAndStats.statistics.subscriberCount });
            } else if (effectiveChannelIdToUse) {
                await getSubscriberCount(effectiveChannelIdToUse);
            }
            if (liveChatId) {
                const chatAvailableMessage = document.createElement("div");
                chatAvailableMessage.innerText = "Connected to live chat.";
                document.getElementById('textarea').appendChild(chatAvailableMessage);
                fetchChatMessages();
            } else {
                 const noChatMessage = document.createElement("div");
                 noChatMessage.style.color = "orange";
                 noChatMessage.innerText = "Live chat is not currently active for this stream.";
                 document.getElementById('textarea').appendChild(noChatMessage);
            }
            if (pollInterval) clearInterval(pollInterval);
            pollInterval = setInterval(() => {
                if (currentStream && currentStream.id && liveChatId) getStreamStats();
                if (effectiveChannelIdToUse) getChannelStats(effectiveChannelIdToUse);
            }, 30000);
            console.log('Connection process complete for target:', channelDisplayNameToUse);
            if (channelInput.value && channelToUse) channelInput.value = '';
        } catch (error) {
            console.error('Error connecting to YouTube:', error);
            updateHeaderInfo(username, 'Connection failed');
            const textarea = document.querySelector("#textarea");
            if (textarea) {
                textarea.innerHTML = '';
                var span = document.createElement("div");
                span.style.color = "red";
                span.innerText = `Error: ${error.message}`;
                textarea.appendChild(span);
            }
            if (channelInputContainer) channelInputContainer.classList.remove('hidden');
            document.getElementById('viewer-count').textContent = '-';
            document.getElementById('subscriber-count').textContent = '-';
            document.getElementById('likes-count').textContent = '-';
        }
    }
	function pushMessage(data) {
		window.dispatchEvent(new CustomEvent('youtubeMessage', { detail: data, bubbles: true }));
	}
    function processMessage(messageData) {
		try {
			const textarea = document.querySelector("#textarea");
			var span = document.createElement("div");
			let badgeHtml = '';
			if (messageData.isChatOwner) badgeHtml += '<img src="https://www.gstatic.com/youtube/img/creator/studio/channel_elements/badges/owner.svg" class="chat-badge" title="Channel Owner">';
			if (messageData.isChatModerator) badgeHtml += '<img src="https://www.gstatic.com/youtube/img/creator/studio/channel_elements/badges/moderator.svg" class="chat-badge" title="Moderator">';
			if (messageData.isChatSponsor) badgeHtml += '<img src="https://www.gstatic.com/youtube/img/creator/studio/channel_elements/badges/sponsor.svg" class="chat-badge" title="Member">';
			span.innerHTML = `${badgeHtml}<strong>${messageData.authorName}</strong>: ${messageData.message}`;
			textarea.appendChild(span);
			
			// Limit to 20 messages
			while (textarea.childNodes.length > 20) {
				textarea.removeChild(textarea.firstChild);
			}
			
			textarea.scrollTop = textarea.scrollHeight;
			pushMessage({
				chatname: messageData.authorName, chatbadges: badgeHtml, backgroundColor: "", textColor: "",
				chatmessage: messageData.message, chatimg: messageData.profileImageUrl || "", hasDonation: "",
				membership: messageData.isChatSponsor ? "member" : "", type: "youtube"
			});
		} catch (e) { console.error('Error processing message:', e); }
	}
    function processSuperChat(superChatData) {
        try {
            addEvent(`Super Chat: ${superChatData.authorName} - ${superChatData.amount}`);
            const textarea = document.querySelector("#textarea");
            var span = document.createElement("div");
            span.innerHTML = `<strong>${superChatData.authorName}</strong> <span style="color:#00c851">${superChatData.amount}</span>: ${superChatData.message || ''}`;
            textarea.appendChild(span);
            if (textarea.childNodes.length > 100) textarea.childNodes[0].remove();
            textarea.scrollTop = textarea.scrollHeight;
            pushMessage({
                chatname: superChatData.authorName, chatbadges: "", backgroundColor: "", textColor: "#00c851",
                chatmessage: superChatData.message || '', chatimg: superChatData.profileImageUrl || "",
                hasDonation: superChatData.amount, membership: "", type: "youtube", event: "donation"
            });
        } catch (e) { console.error('Error processing super chat:', e); }
    }
    function processMembership(membershipData) {
        try {
            addEvent(`New Member: ${membershipData.authorName} - ${membershipData.level}`);
            const textarea = document.querySelector("#textarea");
            var span = document.createElement("div");
            span.innerHTML = `<strong>${membershipData.authorName}</strong> <span style="color:#2196f3">joined as a member (${membershipData.level})</span>`;
            textarea.appendChild(span);
            if (textarea.childNodes.length > 100) textarea.childNodes[0].remove();
            textarea.scrollTop = textarea.scrollHeight;
            pushMessage({
                chatname: membershipData.authorName,
                chatbadges: '<img src="https://www.gstatic.com/youtube/img/creator/studio/channel_elements/badges/sponsor.svg" class="chat-badge" title="Member">',
                backgroundColor: "", textColor: "#2196f3", chatmessage: `joined as a member (${membershipData.level})`,
                chatimg: membershipData.profileImageUrl || "", hasDonation: "", membership: "new_member",
                membershipLevel: membershipData.level, type: "youtube", event: "new_member"
            });
        } catch (e) { console.error('Error processing membership:', e); }
    }
	function updateStats(type, data) {
		switch(type) {
			case 'viewer_update':
				document.getElementById('viewer-count').textContent = data.meta;
				pushMessage({ type: "youtube", event: 'viewer_update', meta: data.meta });
				break;
			case 'subscriber_update':
				document.getElementById('subscriber-count').textContent = data.meta;
				break;
			case 'likes_update':
				document.getElementById('likes-count').textContent = data.meta;
				pushMessage({ type: "youtube", event: 'likes_update', meta: data.meta });
				break;
		}
	}
    function addEvent(text) {
        const eventslist = document.getElementById('events-list');
        const event = document.createElement('div');
        event.className = 'event-item'; event.textContent = text;
        eventslist.insertBefore(event, eventslist.firstChild);
        while (eventslist.children.length > 10) eventslist.removeChild(eventslist.lastChild);
    }
    function updateHeaderInfo(currentUsername, targetName) {
        const currentUserElement = document.getElementById('current-user');
        const currentChannelElement = document.getElementById('current-channel');
        if (currentUserElement) currentUserElement.textContent = currentUsername || 'Not signed in';
        if (currentChannelElement) currentChannelElement.textContent = targetName || 'No target';
    }
    async function fetchWithTimeout(URL, timeout = 8000, headers=false) {
        const controller = new AbortController();
        const timeout_id = setTimeout(() => controller.abort(), timeout);
        try {
            const options = { signal: controller.signal };
            if (headers) options.headers = headers;
            if (headers && headers.method) options.method = headers.method;
            if (headers && headers.body) options.body = headers.body;
            const response = await fetch(URL, options);
            clearTimeout(timeout_id);
            return response;
        } catch (e) {
            clearTimeout(timeout_id);
            console.error('Fetch error or timeout:', e, URL);
            if (e.name === 'AbortError') {
                 throw new Error(`Request timed out: ${URL}`);
            }
            throw e;
        }
    }
    document.addEventListener('DOMContentLoaded', initializePage);
} catch(e) {
    console.error('YouTube integration error:', e);
    const body = document.querySelector('body');
    if (body) {
        const errorDiv = document.createElement('div');
        errorDiv.style.color = 'red';
        errorDiv.style.padding = '20px';
        errorDiv.textContent = 'A critical error occurred with the YouTube integration. Please check the console for details.';
    }
}
</script>
</body>
</html>